{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ERC-1066: FISSION Codes Broadly applicable status codes for Ethereum smart contracts. This standard outlines a common set of Ethereum status codes (ESC) in the same vein as HTTP statuses. This provides a shared set of signals to allow smart contracts to react to situations autonomously, expose localized error messages to users, and so on. The current state of the art is to either revert and require human intervention, or return a Boolean pass/fail status. Status codes are similar-but-orthogonal to revert ing with a reason, but aimed at automation and translation. As is the case with HTTP, having a standard set of known codes has many benefits for developers. They remove friction from needing to develop your own schemes for every contract, makes inter-contract automation easier, and makes it easier to broadly understand which of the finite states your request produced. Importantly, it makes it much easier to distinguish between expected errors states, and truly exceptional conditions that require halting execution. Motivation Autonomy Smart contracts are largely intended to be autonomous. While each contract may define a specific interface, having a common set of semantic codes can help developers write code that can react appropriately to various situations. Semantic Density HTTP status codes are widely used for this purpose. BEAM languages use atoms and tagged tuples to signify much the same information. Both provide a lot of information both to the programmer (debugging for instance), and to the program that needs to decide what to do next. ESCs convey a much richer set of information than Booleans, and are able to be reacted to autonomously unlike arbitrary strings. User Feedback Since status codes are finite and known in advance, we can provide global, human-readable sets of status messages. These may also be translated into any language, differing levels of technical detail, added as revert messages, natspecs, and so on. We also see a desire for this in transactions , and there's no reason that ESCs couldn't be used by the EVM itself. More than Pass/Fail While clearly related, status codes are complementary to \"revert with reason\". ESCs are not limited to rolling back the transaction, and may represent known error states without halting execution. They may also represent off-chain conditions, supply a string to revert, signal time delays, and more. Specification Format Codes are returned as the first value of potentially multiple return values. // Status only function isInt(uint num) public pure returns (byte status) { return hex 01 ; } // Status and value uint8 private counter; function safeIncrement(uint8 interval) public returns (byte status, uint8 newCounter) { uint8 updated = counter + interval; if (updated = counter) { counter = updated; return (hex 01 , updated); } else { return (hex 00 , counter); } } In the rare case that there are multiple codes required to express an idea, they should be organized in ascending order. Code Table X. Low Nibble 0. Generic 10. Permission 20. Find/Match/ c 30. Negotiation / Offers 40. Availability 50. 60. 70. 80. 90. A0. B0. C0. D0. E0. Cryptography F0. Off Chain 0. Failure 0x00 Failure 0x10 Disallowed 0x20 Not Found 0x30 Other Party Disagreed 0x40 Unavailable or Expired 0xE0 Decrypt Failure 0xF0 Off Chain Failure 1. Success 0x01 Success 0x11 Allowed 0x21 Found 0x31 Other Party Agreed 0x41 Available 0xE1 Decrypt Success 0xF1 Off Chain Success 2. Accepted / Started 0x02 Accepted / Started 0x12 Requested Permission 0x22 Match Request Sent 0x32 Sent Offer 0xE2 Signed 0xF2 Off Chain Process Started 3. Awaiting Others 0x03 Awaiting 0x13 Awaiting Permission 0x23 Awaiting Match 0x33 Awaiting Their Ratification 0x43 Not Yet Available 0xE3 Other Party Signature Required 0xF3 Awaiting Off Chain Completion 4. Action Required / Awaiting You 0x04 Action Required 0x14 Awaiting Your Permission 0x34 Awaiting Your Ratification 0x44 Awaiting Your Availability* 0xE4 Your Signature Required 0xF4 Off Chain Action Required 5. 6. 7. 8. 9. A. B. C. D. E. F. Meta/Info 0x0F Metadata Only 0xFF Data Source is Off Chain (ie: no guarantees) Unused regions are available for further extension or custom codes You may need to scroll the tables horizontally (they're pretty wide) Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code's kind or \"category\", and the low nibble contains the state or \"reason\". We present them below as separate tables per range for explanatory and layout reasons. Unspecified codes are not free for arbitrary use, but rather open for further specification. Generic General codes. These double as bare \"reasons\", since 0x01 == 1 . Code Description 0x00 Failure 0x01 Success 0x02 Accepted / Started 0x03 Awaiting / Before 0x04 Action Required 0x05 Expired 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F Meta or Info Only Permission Related to permisson, authorization, approval, and so on. Code Description 0x10 Disallowed 0x11 Allowed 0x12 Requested Permission 0x13 Awaiting Permission 0x14 Awaiting Your Permission 0x15 No Longer Allowed 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F Permission Meta or Info Find, Match, c This range is broadly intended for finding and matching. Data lookups and order matching are two common use cases. Code Description 0x20 Not Found 0x21 Found 0x22 Match Request Sent 0x23 Awaiting Match 0x24 Match Request Received 0x25 Out of Range 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F Matching Meta or Info Negotiation, Terms, and Offers Negotiation, and very broadly the flow of such transactions. Note that \"other party\" may be more than one actor (not necessarily the sender). Code Description 0x30 Other Party Disagreed 0x31 Other Party Agreed 0x32 Sent Offer 0x33 Awaiting Their Ratification 0x34 Awaiting Your Ratification 0x35 Offer Expired 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F Negotiation Meta or Info Availability Service or action availability. Code Description 0x40 Unavailable 0x41 Available 0x42 You May Begin 0x43 Not Yet Available 0x44 Awaiting Your Availability 0x45 No Longer Available 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F Availability Meta or Info 0x5_ TBD Currently unspecified 0x6_ TBD Currently unspecified 0x7_ TBD Currently unspecified 0x8_ TBD Currently unspecified 0x9_ TBD Currently unspecified Application-Specific Codes Contracts may have special states that they need to signal. This proposal only outlines the broadest meanings, but implementers may have very specific meanings for each, as long as they are coherent with the broader definition. Code Description 0xA0 App-Specific Failure 0xA1 App-Specific Success 0xA2 App-Specific Acceptance / Start 0xA3 App-Specific Awaiting / Before 0xA4 App-Specific Action Required 0xA5 App-Specific Expiry 0xA6 0xA7 0xA8 0xA9 0xAA 0xAB 0xAC 0xAD 0xAE 0xAF App-Specific Meta or Info 0xB_ TBD Currently unspecified 0xC_ TBD Currently unspecified 0xD_ TBD Currently unspecified Cryptography and Authentication Actions around signatures, cryptography, signing, and application-level authentication. The meta code 0xEF is often used to signal a payload descibing the algorithm or process used. Code Description 0xE0 Decrypt Failure 0xE1 Decrypt Success 0xE2 Signed 0xE3 Their Signature Required 0xE4 Your Signature Required 0xE5 Auth Expired 0xE6 0xE7 0xE8 0xE9 0xEA 0xEB 0xEC 0xED 0xEE 0xEF Crypto Info or Meta 0xF0 Off-Chain For off-chain actions. Much like th 0x0_: Generic range, 0xF_ is very general, and does little to modify the reason. Among other things, the meta code 0xFF may be used to describe what the off-chain process is. Code Description 0xF0 Off-Chain Failure 0xF1 Off-Chain Success 0xF2 Off-Chain Process Stared 0xF3 Awaiting Off-Chain Completion 0xF4 Off-Chain Action Required 0xF5 Off-Chain Service Unavailable 0xF6 0xF7 0xF8 0xF9 0xFA 0xFB 0xFC 0xFD 0xFE 0xFF Off-Chain Info or Meta Example Function Change uint256 private startTime; mapping(address = uint) private counters; // Before function increase() public returns (bool _available) { if (now startTime counters[msg.sender] == 0) { return false; }; counters[msg.sender] += 1; return true; } // After function increase() public returns (byte _status) { if (now start) { return hex 43 ; } // Not yet available if (counters[msg.sender] == 0) { return hex 10 ; } // Not authorized counters[msg.sender] += 1; return hex 01 ; // Success } Example Sequence Diagrams 0x03 = Waiting 0x31 = Other Party (ie: not you) Agreed 0x41 = Available 0x43 = Not Yet Available Exchange AwesomeCoin DEX TraderBot + + + | | buy(AwesomeCoin) | | | ------------------------+ | buy() | | | ---------------------+ | | | | | Status [0x43] | | +--------------------- | Status [0x43] | | +------------------------ | | | | | | isDoneYet() | | | ------------------------+ | | | | | Status [0x43] | | +------------------------ | | | | | | | | Status [0x41] | | +--------------------- | | | | | | buy() | | | ---------------------+ | | | | | | | | Status [0x31] | | +--------------------- | Status [0x31] | | +------------------------ | | | | | | | | | | | | | + + + 0x01 = Generic Success 0x10 = Disallowed 0x11 = Allowed Token Validation Buyer RegulatedToken TokenValidator IDChecker SpendLimiter + + + + + | buy() | | | | +------------------------ | check() | | | | +----------------------- | check() | | | | +----------------------- | | | | | | | | | | Status [0x10] | | | | Status [0x10] | -----------------------+ | | revert() | -----------------------+ | | | ------------------------+ | | | | | | | | +---------------------------+ | | | | | | | | | | | Updates ID with provider | | | | | | | | | | | +---------------------------+ | | | | | | | | | | buy() | | | | +------------------------ | check() | | | | +----------------------- | check() | | | | +----------------------- | | | | | | | | | | Status [0x11] | | | | | -----------------------+ | | | | | | | | | | check() | | | +------------------------------------------- | | | | | | | | | | Status [0x11] | | | Status [0x11] | -------------------------------------------+ | Status [0x01] | -----------------------+ | | | ------------------------+ | | | | | | | | | | | | | | | | | | + + + + + Rationale Encoding ESCs are encoded as a byte . Hex values break nicely into high and low nibbles: category and reason . For instance, hex\"01\" stands for general success and hex\"00\" for general failure. byte is quite lightweight, and can be easily packed with multiple codes into a bytes32 (or similar) if desired. It is also easily interoperable with uint8 , cast from enum s, and so on. Alternatives Alternate schemes include bytes32 and uint8 . While these work reasonably well, they have drawbacks. uint8 feels even more similar to HTTP status codes, and enums don't require as much casting. However does not break as evenly as a square table (256 doesn't look as nice in base 10). Packing multiple codes into a single bytes32 is nice in theory, but poses additional challenges. Unused space may be interpeted as 0x00 Failure , you can only efficiently pack four codes at once, and there is a challenge in ensuring that code combinations are sensible. Forcing four codes into a packed representation encourages multiple status codes to be returned, which is often more information than strictly nessesary. This can lead to paradoxical results (ex 0x00 and 0x01 together), or greater resorces allocated to interpreting 256 4 (4.3 billion) permutations. Multiple Returns While there may be cases where packing a byte array of ESCs may make sense, the simplest, most forwards-compatible method of transmission is as the first value of a multiple return. Familiarity is also a motivating factor. A consistent position and encoding together follow the principle of least surprise. It is both viewable as a \"header\" in the HTTP analogy, or like the \"tag\" in BEAM tagged tupples. Human Readable Developers should not be required to memorize 256 codes. However, they break nicely into a table. Cognitive load is lowered by organizing the table into categories and reasons. 0x10 and 0x11 belong to the same category, and 0x04 shares a reason with 0x24 While this repository includes helper enums, we have found working directly in the hex values to be quite natural. ESC 0x10 is just as comfortable as HTTP 401, for example. Extensiblilty The 0xA category is reserved for application-specific statuses. In the case that 256 codes become insufficient, bytes1 may be embedded in larger byte arrays. EVM Codes The EVM also returns a status code in transactions; specifically 0x00 and 0x01 . This proposal both matches the meanings of those two codes, and could later be used at the EVM level. Empty Space Much like how HTTP status codes have large unused ranges, there are totally empty sections in this proposal. The intent is to not impose a complete set of codes up front, and to allow users to suggest uses for these spaces as time progresses. Nibble Order Nibble order makes no difference to the machine, and is purely mnemonic. This design was originally in opposite order, but changed it for a few convenience factors. Since it's a different scheme from HTTP, it may feel strange initially, but becomes very natural after a couple hours of use. Short Forms Generic is 0x0_ , general codes are consistent with their integer representations hex 1 == hex 01 == 1 // with casting Contract Categories Many applications will always be part of the same category. For instance, validation will generally be in the 0x10 range. contract Whitelist { mapping(address = bool) private whitelist; uint256 private deadline; byte constant private prefix = hex 10 ; check(address _, address _user) returns (byte _status) { if (now = deadline) { return prefix | 5; } if (whitelist[_user]) { return prefix | 1; } return prefix; } } Helpers This above also means that working with app-specific enums is slightly easier: enum Sleep { Awake, Asleep, REM, FallingAsleep } // From the helper library function appCode(Sleep _state) returns (byte code) { return byte(160 + _state); // 160 = 0xA0 } // Versus function appCode(Sleep _state) returns (byte code) { return byte((16 * _state) + 10); // 10 = 0xA } Implementation Reference cases and helper libraries (Solidity and JS) can be found at: Source Code Package on npm","title":"ERC-1066"},{"location":"#erc-1066-fission-codes","text":"","title":"ERC-1066: FISSION Codes"},{"location":"#broadly-applicable-status-codes-for-ethereum-smart-contracts","text":"This standard outlines a common set of Ethereum status codes (ESC) in the same vein as HTTP statuses. This provides a shared set of signals to allow smart contracts to react to situations autonomously, expose localized error messages to users, and so on. The current state of the art is to either revert and require human intervention, or return a Boolean pass/fail status. Status codes are similar-but-orthogonal to revert ing with a reason, but aimed at automation and translation. As is the case with HTTP, having a standard set of known codes has many benefits for developers. They remove friction from needing to develop your own schemes for every contract, makes inter-contract automation easier, and makes it easier to broadly understand which of the finite states your request produced. Importantly, it makes it much easier to distinguish between expected errors states, and truly exceptional conditions that require halting execution.","title":"Broadly applicable status codes for Ethereum smart contracts."},{"location":"#motivation","text":"","title":"Motivation"},{"location":"#autonomy","text":"Smart contracts are largely intended to be autonomous. While each contract may define a specific interface, having a common set of semantic codes can help developers write code that can react appropriately to various situations.","title":"Autonomy"},{"location":"#semantic-density","text":"HTTP status codes are widely used for this purpose. BEAM languages use atoms and tagged tuples to signify much the same information. Both provide a lot of information both to the programmer (debugging for instance), and to the program that needs to decide what to do next. ESCs convey a much richer set of information than Booleans, and are able to be reacted to autonomously unlike arbitrary strings.","title":"Semantic Density"},{"location":"#user-feedback","text":"Since status codes are finite and known in advance, we can provide global, human-readable sets of status messages. These may also be translated into any language, differing levels of technical detail, added as revert messages, natspecs, and so on. We also see a desire for this in transactions , and there's no reason that ESCs couldn't be used by the EVM itself.","title":"User Feedback"},{"location":"#more-than-passfail","text":"While clearly related, status codes are complementary to \"revert with reason\". ESCs are not limited to rolling back the transaction, and may represent known error states without halting execution. They may also represent off-chain conditions, supply a string to revert, signal time delays, and more.","title":"More than Pass/Fail"},{"location":"#specification","text":"","title":"Specification"},{"location":"#format","text":"Codes are returned as the first value of potentially multiple return values. // Status only function isInt(uint num) public pure returns (byte status) { return hex 01 ; } // Status and value uint8 private counter; function safeIncrement(uint8 interval) public returns (byte status, uint8 newCounter) { uint8 updated = counter + interval; if (updated = counter) { counter = updated; return (hex 01 , updated); } else { return (hex 00 , counter); } } In the rare case that there are multiple codes required to express an idea, they should be organized in ascending order.","title":"Format"},{"location":"#code-table","text":"X. Low Nibble 0. Generic 10. Permission 20. Find/Match/ c 30. Negotiation / Offers 40. Availability 50. 60. 70. 80. 90. A0. B0. C0. D0. E0. Cryptography F0. Off Chain 0. Failure 0x00 Failure 0x10 Disallowed 0x20 Not Found 0x30 Other Party Disagreed 0x40 Unavailable or Expired 0xE0 Decrypt Failure 0xF0 Off Chain Failure 1. Success 0x01 Success 0x11 Allowed 0x21 Found 0x31 Other Party Agreed 0x41 Available 0xE1 Decrypt Success 0xF1 Off Chain Success 2. Accepted / Started 0x02 Accepted / Started 0x12 Requested Permission 0x22 Match Request Sent 0x32 Sent Offer 0xE2 Signed 0xF2 Off Chain Process Started 3. Awaiting Others 0x03 Awaiting 0x13 Awaiting Permission 0x23 Awaiting Match 0x33 Awaiting Their Ratification 0x43 Not Yet Available 0xE3 Other Party Signature Required 0xF3 Awaiting Off Chain Completion 4. Action Required / Awaiting You 0x04 Action Required 0x14 Awaiting Your Permission 0x34 Awaiting Your Ratification 0x44 Awaiting Your Availability* 0xE4 Your Signature Required 0xF4 Off Chain Action Required 5. 6. 7. 8. 9. A. B. C. D. E. F. Meta/Info 0x0F Metadata Only 0xFF Data Source is Off Chain (ie: no guarantees) Unused regions are available for further extension or custom codes You may need to scroll the tables horizontally (they're pretty wide) Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code's kind or \"category\", and the low nibble contains the state or \"reason\". We present them below as separate tables per range for explanatory and layout reasons. Unspecified codes are not free for arbitrary use, but rather open for further specification.","title":"Code Table"},{"location":"#generic","text":"General codes. These double as bare \"reasons\", since 0x01 == 1 . Code Description 0x00 Failure 0x01 Success 0x02 Accepted / Started 0x03 Awaiting / Before 0x04 Action Required 0x05 Expired 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F Meta or Info Only","title":"Generic"},{"location":"#permission","text":"Related to permisson, authorization, approval, and so on. Code Description 0x10 Disallowed 0x11 Allowed 0x12 Requested Permission 0x13 Awaiting Permission 0x14 Awaiting Your Permission 0x15 No Longer Allowed 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F Permission Meta or Info","title":"Permission"},{"location":"#find-match-c","text":"This range is broadly intended for finding and matching. Data lookups and order matching are two common use cases. Code Description 0x20 Not Found 0x21 Found 0x22 Match Request Sent 0x23 Awaiting Match 0x24 Match Request Received 0x25 Out of Range 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F Matching Meta or Info","title":"Find, Match, &amp;c"},{"location":"#negotiation-terms-and-offers","text":"Negotiation, and very broadly the flow of such transactions. Note that \"other party\" may be more than one actor (not necessarily the sender). Code Description 0x30 Other Party Disagreed 0x31 Other Party Agreed 0x32 Sent Offer 0x33 Awaiting Their Ratification 0x34 Awaiting Your Ratification 0x35 Offer Expired 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F Negotiation Meta or Info","title":"Negotiation, Terms, and Offers"},{"location":"#availability","text":"Service or action availability. Code Description 0x40 Unavailable 0x41 Available 0x42 You May Begin 0x43 Not Yet Available 0x44 Awaiting Your Availability 0x45 No Longer Available 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F Availability Meta or Info","title":"Availability"},{"location":"#0x5_-tbd","text":"Currently unspecified","title":"0x5_ TBD"},{"location":"#0x6_-tbd","text":"Currently unspecified","title":"0x6_ TBD"},{"location":"#0x7_-tbd","text":"Currently unspecified","title":"0x7_ TBD"},{"location":"#0x8_-tbd","text":"Currently unspecified","title":"0x8_ TBD"},{"location":"#0x9_-tbd","text":"Currently unspecified","title":"0x9_ TBD"},{"location":"#application-specific-codes","text":"Contracts may have special states that they need to signal. This proposal only outlines the broadest meanings, but implementers may have very specific meanings for each, as long as they are coherent with the broader definition. Code Description 0xA0 App-Specific Failure 0xA1 App-Specific Success 0xA2 App-Specific Acceptance / Start 0xA3 App-Specific Awaiting / Before 0xA4 App-Specific Action Required 0xA5 App-Specific Expiry 0xA6 0xA7 0xA8 0xA9 0xAA 0xAB 0xAC 0xAD 0xAE 0xAF App-Specific Meta or Info","title":"Application-Specific Codes"},{"location":"#0xb_-tbd","text":"Currently unspecified","title":"0xB_ TBD"},{"location":"#0xc_-tbd","text":"Currently unspecified","title":"0xC_ TBD"},{"location":"#0xd_-tbd","text":"Currently unspecified","title":"0xD_ TBD"},{"location":"#cryptography-and-authentication","text":"Actions around signatures, cryptography, signing, and application-level authentication. The meta code 0xEF is often used to signal a payload descibing the algorithm or process used. Code Description 0xE0 Decrypt Failure 0xE1 Decrypt Success 0xE2 Signed 0xE3 Their Signature Required 0xE4 Your Signature Required 0xE5 Auth Expired 0xE6 0xE7 0xE8 0xE9 0xEA 0xEB 0xEC 0xED 0xEE 0xEF Crypto Info or Meta","title":"Cryptography and Authentication"},{"location":"#0xf0-off-chain","text":"For off-chain actions. Much like th 0x0_: Generic range, 0xF_ is very general, and does little to modify the reason. Among other things, the meta code 0xFF may be used to describe what the off-chain process is. Code Description 0xF0 Off-Chain Failure 0xF1 Off-Chain Success 0xF2 Off-Chain Process Stared 0xF3 Awaiting Off-Chain Completion 0xF4 Off-Chain Action Required 0xF5 Off-Chain Service Unavailable 0xF6 0xF7 0xF8 0xF9 0xFA 0xFB 0xFC 0xFD 0xFE 0xFF Off-Chain Info or Meta","title":"0xF0 Off-Chain"},{"location":"#example-function-change","text":"uint256 private startTime; mapping(address = uint) private counters; // Before function increase() public returns (bool _available) { if (now startTime counters[msg.sender] == 0) { return false; }; counters[msg.sender] += 1; return true; } // After function increase() public returns (byte _status) { if (now start) { return hex 43 ; } // Not yet available if (counters[msg.sender] == 0) { return hex 10 ; } // Not authorized counters[msg.sender] += 1; return hex 01 ; // Success }","title":"Example Function Change"},{"location":"#example-sequence-diagrams","text":"0x03 = Waiting 0x31 = Other Party (ie: not you) Agreed 0x41 = Available 0x43 = Not Yet Available Exchange AwesomeCoin DEX TraderBot + + + | | buy(AwesomeCoin) | | | ------------------------+ | buy() | | | ---------------------+ | | | | | Status [0x43] | | +--------------------- | Status [0x43] | | +------------------------ | | | | | | isDoneYet() | | | ------------------------+ | | | | | Status [0x43] | | +------------------------ | | | | | | | | Status [0x41] | | +--------------------- | | | | | | buy() | | | ---------------------+ | | | | | | | | Status [0x31] | | +--------------------- | Status [0x31] | | +------------------------ | | | | | | | | | | | | | + + + 0x01 = Generic Success 0x10 = Disallowed 0x11 = Allowed Token Validation Buyer RegulatedToken TokenValidator IDChecker SpendLimiter + + + + + | buy() | | | | +------------------------ | check() | | | | +----------------------- | check() | | | | +----------------------- | | | | | | | | | | Status [0x10] | | | | Status [0x10] | -----------------------+ | | revert() | -----------------------+ | | | ------------------------+ | | | | | | | | +---------------------------+ | | | | | | | | | | | Updates ID with provider | | | | | | | | | | | +---------------------------+ | | | | | | | | | | buy() | | | | +------------------------ | check() | | | | +----------------------- | check() | | | | +----------------------- | | | | | | | | | | Status [0x11] | | | | | -----------------------+ | | | | | | | | | | check() | | | +------------------------------------------- | | | | | | | | | | Status [0x11] | | | Status [0x11] | -------------------------------------------+ | Status [0x01] | -----------------------+ | | | ------------------------+ | | | | | | | | | | | | | | | | | | + + + + +","title":"Example Sequence Diagrams"},{"location":"#rationale","text":"","title":"Rationale"},{"location":"#encoding","text":"ESCs are encoded as a byte . Hex values break nicely into high and low nibbles: category and reason . For instance, hex\"01\" stands for general success and hex\"00\" for general failure. byte is quite lightweight, and can be easily packed with multiple codes into a bytes32 (or similar) if desired. It is also easily interoperable with uint8 , cast from enum s, and so on.","title":"Encoding"},{"location":"#alternatives","text":"Alternate schemes include bytes32 and uint8 . While these work reasonably well, they have drawbacks. uint8 feels even more similar to HTTP status codes, and enums don't require as much casting. However does not break as evenly as a square table (256 doesn't look as nice in base 10). Packing multiple codes into a single bytes32 is nice in theory, but poses additional challenges. Unused space may be interpeted as 0x00 Failure , you can only efficiently pack four codes at once, and there is a challenge in ensuring that code combinations are sensible. Forcing four codes into a packed representation encourages multiple status codes to be returned, which is often more information than strictly nessesary. This can lead to paradoxical results (ex 0x00 and 0x01 together), or greater resorces allocated to interpreting 256 4 (4.3 billion) permutations.","title":"Alternatives"},{"location":"#multiple-returns","text":"While there may be cases where packing a byte array of ESCs may make sense, the simplest, most forwards-compatible method of transmission is as the first value of a multiple return. Familiarity is also a motivating factor. A consistent position and encoding together follow the principle of least surprise. It is both viewable as a \"header\" in the HTTP analogy, or like the \"tag\" in BEAM tagged tupples.","title":"Multiple Returns"},{"location":"#human-readable","text":"Developers should not be required to memorize 256 codes. However, they break nicely into a table. Cognitive load is lowered by organizing the table into categories and reasons. 0x10 and 0x11 belong to the same category, and 0x04 shares a reason with 0x24 While this repository includes helper enums, we have found working directly in the hex values to be quite natural. ESC 0x10 is just as comfortable as HTTP 401, for example.","title":"Human Readable"},{"location":"#extensiblilty","text":"The 0xA category is reserved for application-specific statuses. In the case that 256 codes become insufficient, bytes1 may be embedded in larger byte arrays.","title":"Extensiblilty"},{"location":"#evm-codes","text":"The EVM also returns a status code in transactions; specifically 0x00 and 0x01 . This proposal both matches the meanings of those two codes, and could later be used at the EVM level.","title":"EVM Codes"},{"location":"#empty-space","text":"Much like how HTTP status codes have large unused ranges, there are totally empty sections in this proposal. The intent is to not impose a complete set of codes up front, and to allow users to suggest uses for these spaces as time progresses.","title":"Empty Space"},{"location":"#nibble-order","text":"Nibble order makes no difference to the machine, and is purely mnemonic. This design was originally in opposite order, but changed it for a few convenience factors. Since it's a different scheme from HTTP, it may feel strange initially, but becomes very natural after a couple hours of use.","title":"Nibble Order"},{"location":"#short-forms","text":"Generic is 0x0_ , general codes are consistent with their integer representations hex 1 == hex 01 == 1 // with casting","title":"Short Forms"},{"location":"#contract-categories","text":"Many applications will always be part of the same category. For instance, validation will generally be in the 0x10 range. contract Whitelist { mapping(address = bool) private whitelist; uint256 private deadline; byte constant private prefix = hex 10 ; check(address _, address _user) returns (byte _status) { if (now = deadline) { return prefix | 5; } if (whitelist[_user]) { return prefix | 1; } return prefix; } }","title":"Contract Categories"},{"location":"#helpers","text":"This above also means that working with app-specific enums is slightly easier: enum Sleep { Awake, Asleep, REM, FallingAsleep } // From the helper library function appCode(Sleep _state) returns (byte code) { return byte(160 + _state); // 160 = 0xA0 } // Versus function appCode(Sleep _state) returns (byte code) { return byte((16 * _state) + 10); // 10 = 0xA }","title":"Helpers"},{"location":"#implementation","text":"Reference cases and helper libraries (Solidity and JS) can be found at: Source Code Package on npm","title":"Implementation"},{"location":"ERC1444/","text":"ERC-1444 A method of converting machine codes to human-readable text in any language and phrasing. An on-chain system for providing user feedback by converting machine-efficient codes into human-readable strings in any language or phrasing. The system does not impose a list of languages, but rather lets users create, share, and use the localizated text of their choice. Motivation There are many cases where an end user needs feedback or instruction from a smart contact. Directly exposing numeric codes does not make for good UX or DX. If Ethereum is to be a truly global system usable by experts and lay persons alike, systems to provide feedback on what happened during a transaction are needed in as many languages as possible. Returning a hard-coded string (typically in English) only serves a small segment of the global population. This standard proposes a method to allow users to create, register, share, and use a decentralized collection of translations, enabling richer messaging that is more culturally and linguistically diverse. There are several machine efficient ways of representing intent, status, state transition, and other semantic signals including booleans, enums and ERC-1066 codes . By providing human-readable messages for these signals, the developer experience is enhanced by returning easier to consume information with more context (ex. revert ). End user experience is enhanced by providing text that can be propagated up to the UI. Specification Contract Architecture Two types of contract: LocalizationPreferences , and Localization s. The LocalizationPreferences contract functions as a proxy for tx.origin . +--------------+ | | +------ | Localization | | | | | +--------------+ | | +-----------+ +-------------------------+ | +--------------+ | | | | ------+ | | | Requestor | ------ | LocalizationPreferences | ------------- | Localization | | | | | ------+ | | +-----------+ +-------------------------+ | +--------------+ | | | +--------------+ | | | +------ | Localization | | | +--------------+ Localization A contract that holds a simple mapping of codes to their text representations. interface Localization { function textFor(bytes32 _code) external view returns (string _text); } textFor Fetches the localized text representation. function textFor(bytes32 _code) external view returns (string _text); LocalizationPreferences A proxy contract that allows users to set their preferred Localization . Text lookup is delegated to the user's preferred contract. A fallback Localization with all keys filled MUST be available. If the user-specified Localization has not explicitly set a loalization (ie. textFor returns \"\" ), the LocalizationPreferences MUST redelegate to the fallback Localization . interface LocalizationPreferences { function set(Localization _localization) external returns (bool); function textFor(bytes32 _code) external view returns (bool _wasFound, string _text); } set Registers a user's preferred Localization . The registering user SHOULD be considered tx.origin . function set(Localization _localization) external; textFor Retrieve text for a code found at the user's preferred Localization contract. The first return value ( bool _wasFound ) represents if the text is available from that Localization , or if a fallback was used. If the fallback was used in this context, the textFor 's first return value MUST be set to false , and is true otherwise. function textFor(bytes32 _code) external view returns (bool _wasFound, string _text); String Format All strings MUST be encoded as UTF-8 . \u0160pe\u0109i\u00e4l ch\u00e2r\u00e3\u00e7t\u00e9rs are permitted As are non-Latin characters: \u30a2\u30eb\u30df\u7f36\u306e\u4e0a\u306b\u3042\u308b\u307f\u304b\u3093\u3002 Emoji are legal: \ud83d\ude48\ud83d\ude49\ud83d\ude4a\ud83c\udf89 Feel free to be creative: (\uff89\u25d5\u30ee\u25d5)\uff89*:\uff65\uff9f\u2727 Templates Template strings are allowed, and MUST follow the ANSI C printf conventions. Satoshi's true identity is %s Text with 2 or more arguments SHOULD use the POSIX parameter field extension. Knock knock. Who's there? %1$s. %1$s who? %2$s! Rationale bytes32 Keys bytes32 is very efficient since it is the EVM's base word size. Given the enormous number of elements (|A| 1.1579 \u00d7 10 77 ), it can embed nearly any practical signal, enum, or state. In cases where an application's key is longer than bytes32 , hashing that long key can map that value into the correct width. Designs that use datatypes with small widths than bytes32 (such as bytes1 in ERC-1066 ) can be directly embedded into the larger width. This is a trivial one-to-one mapping of the smaller set into the the larger one. Local vs Globals and Singletons This spec has opted to not force a single global registry, and rather allow any contract and use case deploy their own system. This allows for more flexibility, and does not restrict the community for opting to use singleton LocalizationPreference contracts for common use cases, share Localization s between different proxys, delegate translations between Localization s, and so on. There are many practical uses of agreed upon singletons. For instance, translating codes that aim to be fairly universal and integrated directly into the broader ecosystem (wallets, frameworks, debuggers, and the like) will want to have a single LocalizationPreference . Rather the dispersing several LocalizationPreference s for different use cases and codes, one could imagine a global \"registry of registries\". While this approach allows for a unified lookups of all translations in all use cases, it is antithetical to the spirit of decentralization and freedom. Such a system also increases the lookup complexity, places an onus on getting the code right the first time (or adding the overhead of an upgradable contract), and need to account for use case conflicts with a \"unified\" or centralized numbering system. Further, lookups should be lightweight (especially in cases like looking up revert text). For these reasons, this spec chooses the more decentralized, lightweight, free approach, at the cost of on-chain discoverability. A registry could still be compiled, but would be difficult to enforce, and is out of scope of this spec. Off Chain Storage A very viable alternative is to store text off chain, with a pointer to the translations on-chain, and emit or return a bytes32 code for another party to do the lookup. It is difficult to guarantee that off-chain resources will be available, and requires coordination from some other system like a web server to do the code-to-text matching. This is also not compatible with revert messages. ASCII vs UTF-8 vs UTF-16 UTF-8 is the most widely used encoding at time of writing. It contains a direct embedding of ASCII, while providing characters for most natural languages, emoji, and special characters. Please see the UTF-8 Everywhere Manifesto for more information. When No Text is Found Returning a blank string to the requestor fully defeats the purpose of a localization system. The two options for handling missing text are: A generic \"text not found\" message in the preferred language The actual message, in a different language Generic Option This designed opted to not use generic fallback text. It does not provide any useful information to the user other than to potentially contact the Localization maintainer (if one even exists and updating is even possible). Fallback Option The design outlined in this proposal is to providing text in a commonly used language (ex. English or Mandarin). First, this is the language that will be routed to if the user has yet to set a preference. Second, there is a good chance that a user may have some proficiency with the language, or at least be able to use an automated translation service. Knowing that the text fell back via textFor s first return field boolean is much simpler than attempting language detection after the fact. This information is useful for certain UI cases. for example where there may be a desire to explain why localization fell back. Decentralized Text Crowdsourcing In order for Ethereum to gain mass adoption, users must be able to interact with it in the language, phrasing, and level of detail that they are most comfortable with. Rather than imposing a fixed set of translations as in a traditional, centralized application, this EIP provides a way for anyone to create, curate, and use translations. This empowers the crowd to supply culturally and linguistically diverse messaging, leading to broader and more distributed access to information. printf -style Format Strings C-style printf templates have been the de facto standard for some time. They have wide compatibility across most languages (either in standard or third-party libraries). This makes it much easier for the consuming program to interpolate strings with low developer overhead. Parameter Fields The POSIX parameter field extension is important since languages do not share a common word order. Parameter fields enable the reuse and rearrangement of arguments in different localizations. ( %1$s is an element with the atomic number %2$d! , Mercury , 80); // = Mercury is an element with the atomic number 80! Simplified Localizations Localization text does not require use of all parameters, and may simply ignore values. This can be useful for not exposing more technical information to users that would otherwise find it confusing. #!/usr/bin/env ruby sprintf( %1$s \u00e9 um elemento , Mercurio , 80) # = Mercurio \u00e9 um elemento #!/usr/bin/env clojure (format Element #%2$s Mercury 80) ;; = Element #80 Interpolation Strategy Please note that it is highly advisable to return the template string as is , with arguments as multiple return values or fields in an event , leaving the actual interpolation to be done off chain. event AtomMessage { bytes32 templateCode; bytes32 atomCode; uint256 atomicNumber; } #!/usr/bin/env node var printf = require('printf'); const { returnValues: { templateCode, atomCode, atomicNumber } } = eventResponse; const template = await AppText.textFor(templateCode); // = %1$s ist ein Element mit der Ordnungszahl %2$d! const atomName = await PeriodicTableText.textFor(atomCode); // = Merkur printf(template, atomName, 80); // = Merkur ist ein Element mit der Ordnungszahl 80! Unspecified Behaviour This spec does not specify: Public or private access to the default Localization Who may set text Deployer onlyOwner Anyone Whitelisted users and so on When text is set constructor Any time Write to empty slots, but not overwrite existing text and so on These are intentionally left open. There are many cases for each of these, and restricting any is fully beyond the scope of this proposal. Implementation Reference cases and helper libraries (Solidity and JS) can be found at: Package on npm FISSION Translate","title":"ERC-1444"},{"location":"ERC1444/#erc-1444","text":"","title":"ERC-1444"},{"location":"ERC1444/#a-method-of-converting-machine-codes-to-human-readable-text-in-any-language-and-phrasing","text":"An on-chain system for providing user feedback by converting machine-efficient codes into human-readable strings in any language or phrasing. The system does not impose a list of languages, but rather lets users create, share, and use the localizated text of their choice.","title":"A method of converting machine codes to human-readable text in any language and phrasing."},{"location":"ERC1444/#motivation","text":"There are many cases where an end user needs feedback or instruction from a smart contact. Directly exposing numeric codes does not make for good UX or DX. If Ethereum is to be a truly global system usable by experts and lay persons alike, systems to provide feedback on what happened during a transaction are needed in as many languages as possible. Returning a hard-coded string (typically in English) only serves a small segment of the global population. This standard proposes a method to allow users to create, register, share, and use a decentralized collection of translations, enabling richer messaging that is more culturally and linguistically diverse. There are several machine efficient ways of representing intent, status, state transition, and other semantic signals including booleans, enums and ERC-1066 codes . By providing human-readable messages for these signals, the developer experience is enhanced by returning easier to consume information with more context (ex. revert ). End user experience is enhanced by providing text that can be propagated up to the UI.","title":"Motivation"},{"location":"ERC1444/#specification","text":"","title":"Specification"},{"location":"ERC1444/#contract-architecture","text":"Two types of contract: LocalizationPreferences , and Localization s. The LocalizationPreferences contract functions as a proxy for tx.origin . +--------------+ | | +------ | Localization | | | | | +--------------+ | | +-----------+ +-------------------------+ | +--------------+ | | | | ------+ | | | Requestor | ------ | LocalizationPreferences | ------------- | Localization | | | | | ------+ | | +-----------+ +-------------------------+ | +--------------+ | | | +--------------+ | | | +------ | Localization | | | +--------------+","title":"Contract Architecture"},{"location":"ERC1444/#localization","text":"A contract that holds a simple mapping of codes to their text representations. interface Localization { function textFor(bytes32 _code) external view returns (string _text); }","title":"Localization"},{"location":"ERC1444/#textfor","text":"Fetches the localized text representation. function textFor(bytes32 _code) external view returns (string _text);","title":"textFor"},{"location":"ERC1444/#localizationpreferences","text":"A proxy contract that allows users to set their preferred Localization . Text lookup is delegated to the user's preferred contract. A fallback Localization with all keys filled MUST be available. If the user-specified Localization has not explicitly set a loalization (ie. textFor returns \"\" ), the LocalizationPreferences MUST redelegate to the fallback Localization . interface LocalizationPreferences { function set(Localization _localization) external returns (bool); function textFor(bytes32 _code) external view returns (bool _wasFound, string _text); }","title":"LocalizationPreferences"},{"location":"ERC1444/#set","text":"Registers a user's preferred Localization . The registering user SHOULD be considered tx.origin . function set(Localization _localization) external;","title":"set"},{"location":"ERC1444/#textfor_1","text":"Retrieve text for a code found at the user's preferred Localization contract. The first return value ( bool _wasFound ) represents if the text is available from that Localization , or if a fallback was used. If the fallback was used in this context, the textFor 's first return value MUST be set to false , and is true otherwise. function textFor(bytes32 _code) external view returns (bool _wasFound, string _text);","title":"textFor"},{"location":"ERC1444/#string-format","text":"All strings MUST be encoded as UTF-8 . \u0160pe\u0109i\u00e4l ch\u00e2r\u00e3\u00e7t\u00e9rs are permitted As are non-Latin characters: \u30a2\u30eb\u30df\u7f36\u306e\u4e0a\u306b\u3042\u308b\u307f\u304b\u3093\u3002 Emoji are legal: \ud83d\ude48\ud83d\ude49\ud83d\ude4a\ud83c\udf89 Feel free to be creative: (\uff89\u25d5\u30ee\u25d5)\uff89*:\uff65\uff9f\u2727","title":"String Format"},{"location":"ERC1444/#templates","text":"Template strings are allowed, and MUST follow the ANSI C printf conventions. Satoshi's true identity is %s Text with 2 or more arguments SHOULD use the POSIX parameter field extension. Knock knock. Who's there? %1$s. %1$s who? %2$s!","title":"Templates"},{"location":"ERC1444/#rationale","text":"","title":"Rationale"},{"location":"ERC1444/#bytes32-keys","text":"bytes32 is very efficient since it is the EVM's base word size. Given the enormous number of elements (|A| 1.1579 \u00d7 10 77 ), it can embed nearly any practical signal, enum, or state. In cases where an application's key is longer than bytes32 , hashing that long key can map that value into the correct width. Designs that use datatypes with small widths than bytes32 (such as bytes1 in ERC-1066 ) can be directly embedded into the larger width. This is a trivial one-to-one mapping of the smaller set into the the larger one.","title":"bytes32 Keys"},{"location":"ERC1444/#local-vs-globals-and-singletons","text":"This spec has opted to not force a single global registry, and rather allow any contract and use case deploy their own system. This allows for more flexibility, and does not restrict the community for opting to use singleton LocalizationPreference contracts for common use cases, share Localization s between different proxys, delegate translations between Localization s, and so on. There are many practical uses of agreed upon singletons. For instance, translating codes that aim to be fairly universal and integrated directly into the broader ecosystem (wallets, frameworks, debuggers, and the like) will want to have a single LocalizationPreference . Rather the dispersing several LocalizationPreference s for different use cases and codes, one could imagine a global \"registry of registries\". While this approach allows for a unified lookups of all translations in all use cases, it is antithetical to the spirit of decentralization and freedom. Such a system also increases the lookup complexity, places an onus on getting the code right the first time (or adding the overhead of an upgradable contract), and need to account for use case conflicts with a \"unified\" or centralized numbering system. Further, lookups should be lightweight (especially in cases like looking up revert text). For these reasons, this spec chooses the more decentralized, lightweight, free approach, at the cost of on-chain discoverability. A registry could still be compiled, but would be difficult to enforce, and is out of scope of this spec.","title":"Local vs Globals and Singletons"},{"location":"ERC1444/#off-chain-storage","text":"A very viable alternative is to store text off chain, with a pointer to the translations on-chain, and emit or return a bytes32 code for another party to do the lookup. It is difficult to guarantee that off-chain resources will be available, and requires coordination from some other system like a web server to do the code-to-text matching. This is also not compatible with revert messages.","title":"Off Chain Storage"},{"location":"ERC1444/#ascii-vs-utf-8-vs-utf-16","text":"UTF-8 is the most widely used encoding at time of writing. It contains a direct embedding of ASCII, while providing characters for most natural languages, emoji, and special characters. Please see the UTF-8 Everywhere Manifesto for more information.","title":"ASCII vs UTF-8 vs UTF-16"},{"location":"ERC1444/#when-no-text-is-found","text":"Returning a blank string to the requestor fully defeats the purpose of a localization system. The two options for handling missing text are: A generic \"text not found\" message in the preferred language The actual message, in a different language","title":"When No Text is Found"},{"location":"ERC1444/#generic-option","text":"This designed opted to not use generic fallback text. It does not provide any useful information to the user other than to potentially contact the Localization maintainer (if one even exists and updating is even possible).","title":"Generic Option"},{"location":"ERC1444/#fallback-option","text":"The design outlined in this proposal is to providing text in a commonly used language (ex. English or Mandarin). First, this is the language that will be routed to if the user has yet to set a preference. Second, there is a good chance that a user may have some proficiency with the language, or at least be able to use an automated translation service. Knowing that the text fell back via textFor s first return field boolean is much simpler than attempting language detection after the fact. This information is useful for certain UI cases. for example where there may be a desire to explain why localization fell back.","title":"Fallback Option"},{"location":"ERC1444/#decentralized-text-crowdsourcing","text":"In order for Ethereum to gain mass adoption, users must be able to interact with it in the language, phrasing, and level of detail that they are most comfortable with. Rather than imposing a fixed set of translations as in a traditional, centralized application, this EIP provides a way for anyone to create, curate, and use translations. This empowers the crowd to supply culturally and linguistically diverse messaging, leading to broader and more distributed access to information.","title":"Decentralized Text Crowdsourcing"},{"location":"ERC1444/#printf-style-format-strings","text":"C-style printf templates have been the de facto standard for some time. They have wide compatibility across most languages (either in standard or third-party libraries). This makes it much easier for the consuming program to interpolate strings with low developer overhead.","title":"printf-style Format Strings"},{"location":"ERC1444/#parameter-fields","text":"The POSIX parameter field extension is important since languages do not share a common word order. Parameter fields enable the reuse and rearrangement of arguments in different localizations. ( %1$s is an element with the atomic number %2$d! , Mercury , 80); // = Mercury is an element with the atomic number 80!","title":"Parameter Fields"},{"location":"ERC1444/#simplified-localizations","text":"Localization text does not require use of all parameters, and may simply ignore values. This can be useful for not exposing more technical information to users that would otherwise find it confusing. #!/usr/bin/env ruby sprintf( %1$s \u00e9 um elemento , Mercurio , 80) # = Mercurio \u00e9 um elemento #!/usr/bin/env clojure (format Element #%2$s Mercury 80) ;; = Element #80","title":"Simplified Localizations"},{"location":"ERC1444/#interpolation-strategy","text":"Please note that it is highly advisable to return the template string as is , with arguments as multiple return values or fields in an event , leaving the actual interpolation to be done off chain. event AtomMessage { bytes32 templateCode; bytes32 atomCode; uint256 atomicNumber; } #!/usr/bin/env node var printf = require('printf'); const { returnValues: { templateCode, atomCode, atomicNumber } } = eventResponse; const template = await AppText.textFor(templateCode); // = %1$s ist ein Element mit der Ordnungszahl %2$d! const atomName = await PeriodicTableText.textFor(atomCode); // = Merkur printf(template, atomName, 80); // = Merkur ist ein Element mit der Ordnungszahl 80!","title":"Interpolation Strategy"},{"location":"ERC1444/#unspecified-behaviour","text":"This spec does not specify: Public or private access to the default Localization Who may set text Deployer onlyOwner Anyone Whitelisted users and so on When text is set constructor Any time Write to empty slots, but not overwrite existing text and so on These are intentionally left open. There are many cases for each of these, and restricting any is fully beyond the scope of this proposal.","title":"Unspecified Behaviour"},{"location":"ERC1444/#implementation","text":"Reference cases and helper libraries (Solidity and JS) can be found at: Package on npm FISSION Translate","title":"Implementation"}]}